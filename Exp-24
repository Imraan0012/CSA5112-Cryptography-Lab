def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    else:
        gcd, x1, y1 = extended_gcd(b, a % b)
        x, y = y1, x1 - (a // b) * y1
        return gcd, x, y

def mod_inverse(e, phi):
    gcd, x, _ = extended_gcd(e, phi)
    if gcd != 1:
        raise Exception("No modular inverse exists")
    else:
        return x % phi

# Given values
e = 31
n = 3599
p, q = 59, 61
phi = (p - 1) * (q - 1)

# Compute private key
d = mod_inverse(e, phi)

print("Public key (e, n):", (e, n))
print("Private key (d, n):", (d, n))
