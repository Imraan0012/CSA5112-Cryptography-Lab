import numpy as np

def mod_inverse(a, m):
    # Extended Euclidean Algorithm for modular inverse
    for i in range(1, m):
        if (a * i) % m == 1:
            return i
    return None

def matrix_mod_inv(matrix, modulus):
    det = int(round(np.linalg.det(matrix))) % modulus
    det_inv = mod_inverse(det, modulus)
    if det_inv is None:
        raise ValueError("Matrix not invertible")
    
    # Adjugate matrix for 2x2
    adj = np.array([[matrix[1][1], -matrix[0][1]],
                    [-matrix[1][0], matrix[0][0]]])
    
    inv_matrix = (det_inv * adj) % modulus
    return inv_matrix

def text_to_matrix(text):
    nums = [ord(c) - ord('A') for c in text.upper() if c.isalpha()]
    if len(nums) != 4:
        raise ValueError("Need exactly 4 letters for 2x2 matrix")
    return np.array(nums).reshape(2, 2)

def recover_key(plain, cipher):
    P = text_to_matrix(plain)
    C = text_to_matrix(cipher)
    P_inv = matrix_mod_inv(P, 26)
    return np.dot(P_inv, C) % 26

# Example known plaintext and ciphertext (4 letters each)
plain = "HELP"
cipher = "ZEBR"
key = recover_key(plain, cipher)
print("Recovered key matrix:", key)
